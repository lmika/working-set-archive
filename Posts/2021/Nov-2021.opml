<?xml version="1.0"?>
<opml version="2.0">
	<head>
		<title>Working Set</title>
		<dateCreated>Mon, 11 Oct 2021 22:45:00 GMT</dateCreated>
		<flPublic>true</flPublic>
		<urlPublic>http://drummer.scripting.com/_leonmika/blog.opml</urlPublic>
		<description>A Work Journal</description>
		<copyright>© Leon Mika 2021 • Licensed under Creative Commons Attribution 4.0</copyright>
		<urlHeaderImage>https://images.workingset.net/headings/level-crossing.jpg</urlHeaderImage>
		<timeZoneOffset>+10:00</timeZoneOffset>
		<rssLink>https://workingset.net/rss.xml</rssLink>
		<urlBlogWebsite>https://workingset.net/</urlBlogWebsite>
		<urlAboutOpml>http://drummer.scripting.com/_leonmika/working-set-about.opml</urlAboutOpml>
		<urlTemplate>https://static.workingset.net/templates/index.html</urlTemplate>
		<ownerTwitterScreenName>_leonmika</ownerTwitterScreenName>
		<ownerName>Leon Mika</ownerName>
		<ownerId>http://twitter.com/_leonmika</ownerId>
		<urlUpdateSocket>ws://drummer.scripting.com:1232/</urlUpdateSocket>
		<dateModified>Tue, 04 Jan 2022 22:40:25 GMT</dateModified>
		<expansionState>1,2,4,5,8,16,18,20,23,24,25,35,36,40,42,46,48</expansionState>
		<lastCursor>61</lastCursor>
		</head>
	<body>
		<outline text="November 2021" created="Mon, 01 Nov 2021 04:53:35 GMT" name="november2021" type="calendarMonth">
			<outline text="November 29" created="Mon, 29 Nov 2021 11:03:15 GMT" type="calendarDay" name="29">
				<outline text="Back on Feed Journaler.  I'm looking at a few possible ways to add a preference which will allow launching the application on login, with an optional preference to launch it with the main window visible.  It looks like using Login Items is the way to go (Launch Agents would also work but it hides the application from the &quot;Login Items&quot; preferences pane, which is something that I'd rather not do). Having a checkbox which will add or remove the app from the user's Login Items would be great.&lt;/p&gt;&lt;p&gt;The only question is, what is the best way to do so?  Sadly, after looking around Stack Overflow, most of the answers to that question are rather old — early 2010s — and may not work in today's version of MacOS.  &lt;a href=&quot;https://stackoverflow.com/questions/6947925/add-app-to-osx-login-items-during-a-package-maker-installer-postflight-script&quot;&gt;A Stack Overflow answer&lt;/a&gt; suggested using &lt;code&gt;defaults&lt;/code&gt;, which might work, but the plist files in the answer don't exist on my OS installation, and any files with names that might suggest they have something to do with login items don't contain anything that looks like an application.&lt;/p&gt;&lt;p&gt;I did have more success with &lt;a href=&quot;https://apple.stackexchange.com/questions/230197/how-can-get-an-applescript-to-add-itself-to-the-open-at-login-menu-automatically&quot;&gt;running an Apple script&lt;/a&gt; using &lt;code&gt;osascript&lt;/code&gt;, but doing so will throw up a permissions dialog for access to &quot;System Events&quot;.  This is not the worst thing in the world, but would mean adding preflight logic to check whether I have permission to access System Events first, before either reading or changing the state of login items.  It would also mean more clicks from the user, which may impact the user experience.&lt;/p&gt;&lt;p&gt;Then again, maybe not.  There are some nice things about stating up front that you're doing something with the system.  I hate it when applications just choose to add themselves to the list of Launch Items/Agents without telling me.  Sure it would mean more clicks, but it might not be so bad if the user user is motivated to apply the preference change.  Plus, it's relatively easy to implement, without having to guess whether plist files exist.&lt;/p&gt;&lt;p&gt;So might be the way to go, at least at this stage." created="Mon, 29 Nov 2021 11:43:16 GMT" type="outline"/>
				</outline>
			<outline text="November 26" created="Thu, 25 Nov 2021 22:04:25 GMT" type="calendarDay" name="26">
				<outline text="Ok, after some testing, it looks like it's possible to push requests from AWS API Gateway directly to an SQS queue.  &lt;a href=&quot;https://medium.com/@pranaysankpal/aws-api-gateway-proxy-for-sqs-simple-queue-service-5b08fe18ce50&quot;&gt;This blog post&lt;/a&gt; proved to be very useful in documenting the process.  My advice: follow the instructions to the letter, even if it looks unintuitive (the inability to add policies when creating the API Gateway role was the step that got me).  Still some unanswered questions around request authentication and dealing with problems from SQS, but this is definitely an approach that is worth considering." created="Thu, 25 Nov 2021 23:05:03 GMT" type="outline"/>
				<outline text="I need to setup something that accepts web-hooks from Stripe and push it to the service I'm working on.  Because of the nature of web-hooks, I'd like to be able to accept the event from Stripe, push it onto a queue, and quickly return a 200 OK so as to avoid timing out the web-hook request.  That way, the service consuming the events can handle them in it's own time, and also make use of the SQS's builtin redrive policy to resend the message when an error occurs.  I see that AWS API Gateway has builtin support for pushing requests to a queue, so I'll see if I can make use of that." created="Thu, 25 Nov 2021 22:12:58 GMT" type="outline"/>
				</outline>
			<outline text="November 21" created="Sun, 21 Nov 2021 05:48:38 GMT" type="calendarDay" name="21">
				<outline text="I've found a solution to the &lt;a href=&quot;https://workingset.net/2021/11/13/000200.html?title=altoCatalogueUpdate&quot;&gt;little knot problem&lt;/a&gt; I found myself in a week ago.  I've plowed ahead with a process that involves handling the media twice; which saves me from having to upload the media to the server first, but it does result in a solution that is a little inelegant.  First the media is uploaded to S3 with a temporary name.  This uses the same pre-signed URL that already exists.  Once that's done, the ID3v2 tags from the media would be read by the server, and be used to set the details of the track within the catalogue, such as the title, track number and duration.  Finally, these track details will be used to move the media to its final location.  This dance involves three separate endpoints orchestrated by the JavaScript running in the browser.  It's a little bit convoluted, but hey, it works, and this long standing issue is now closed." created="Sun, 21 Nov 2021 06:00:00 GMT" type="outline"/>
				</outline>
			<outline text="November 18" created="Thu, 18 Nov 2021 02:43:15 GMT" type="calendarDay" name="18">
				<outline text="On Speed vs Flexibility" created="Thu, 18 Nov 2021 03:53:09 GMT" type="outline">
					<outline text="Dealing with the problem I have at the moment, I am reminded on just how fragile the justification of using a pre-canned solution because it's &quot;faster&quot; actually is when it comes at the cost of flexibility." created="Thu, 18 Nov 2021 02:53:38 GMT"/>
					<outline text="Lets say you have a DynamoDB table (sorry, this is going to be an AWS example) and you have a Step Function that needs to make some changes within it.  You have two options before you: you could write a Lambda to do it, or you could use an &quot;&lt;a href=&quot;https://docs.aws.amazon.com/step-functions/latest/dg/connect-supported-services.html&quot;&gt;optimised integration&lt;/a&gt;&quot; in the form of &lt;a href=&quot;https://docs.aws.amazon.com/step-functions/latest/dg/connect-ddb.html&quot;&gt;DynamoDB Step Function tasks&lt;/a&gt;.  If the optimised integration solves your needs at the moment, then using it is definitely faster: just write the necessary YAML and you're done." created="Thu, 18 Nov 2021 03:19:35 GMT"/>
					<outline text="But by taking this route, you're also implicitly taking on the limitations of this pre-canned solution.  Let say that you've moved this DynamoDB table to different region, but the Step Function still needs to access it.  Well, there's no way to do this using the optimised integration (&lt;a href=&quot;https://stackoverflow.com/questions/70014444/using-step-function-optimised-integration-to-access-a-dynamodb-table-in-another&quot;&gt;as far as I know&lt;/a&gt;).  Your needs have now strayed beyond the boundary of what is possible." created="Thu, 18 Nov 2021 03:31:08 GMT"/>
					<outline text="The alternative is to write a Lambda.  Sure it will be much more work upfront — especially if you properly engineer it with tests, etc — but when you're requirements change, you have room to make the necessary chances to meet them.  DynamoDB table moved to a different region?  Just reconfigure the client.  Job done.  It might have seem more expensive to do this up front, but it all pays off when you need the flexibility in order to accomodate the new requirements." created="Thu, 18 Nov 2021 03:02:57 GMT"/>
					<outline text="This tension between the these two trade-offs — speed vs. flexibility — seems to come up quite often for me.  I sometimes feel a little crazy preferring an option which would involve more coding upfront, when a perfectively good pre-canned solution is available to me right here and now.  Maybe I am, I really don't know.  But what I do know is that I really do go crazy when I use a pre-canned solution, hit a roadblock because the circumstances change, and there's nothing I can do about it (apart from write blog posts about it)." created="Thu, 18 Nov 2021 03:33:35 GMT"/>
					</outline>
				</outline>
			<outline text="November 16" created="Mon, 15 Nov 2021 22:37:17 GMT" type="calendarDay" name="16">
				<outline text="IAM Permissions for SSM Parameters in Multiple Regions" created="Mon, 15 Nov 2021 23:12:18 GMT" type="outline">
					<outline text="Here's a small &quot;pro-tip&quot; I discovered this morning regarding SSM parameters and an IAM policy document that grants access to them if they all have the same name but exist in multiple regions." created="Mon, 15 Nov 2021 23:06:28 GMT"/>
					<outline text="The traditional way to allow an AWS service to access an SSM parameter in a given region is to write an IAM policy document like this (this is in YAML):" created="Mon, 15 Nov 2021 22:55:13 GMT" flCodeSubs="true">
						<outline text="Effect: Allow" created="Mon, 15 Nov 2021 23:01:22 GMT"/>
						<outline text="Action:" created="Mon, 15 Nov 2021 23:03:51 GMT">
							<outline text="- SSM:GetParameter" created="Mon, 15 Nov 2021 23:03:58 GMT"/>
							</outline>
						<outline text="Resource:" created="Mon, 15 Nov 2021 23:04:03 GMT">
							<outline text="- arn:aws:ssm:{region}:{account}:parameter/your/parameter/here" created="Mon, 15 Nov 2021 23:04:06 GMT"/>
							</outline>
						</outline>
					<outline text="But let's say you have a service in an AWS region that needs to access SSM parameters in different regions.  All these SSM parameters have the same name but different values in different regions.  You don't know which regions these will be in advanced — say that the SSM parameter value is set in a different stack that you'd want to deploy in another region without needing to modifying the IAM policy." created="Mon, 15 Nov 2021 22:55:09 GMT"/>
					<outline text="I discovered this morning that it's possible to replace the region with an asterisk (&lt;code&gt;*&lt;/code&gt;) in the resource ARN within the IAM policy document, thereby granting access to this named SSM parameter in all regions.  Such a policy document would then look like the following:" created="Mon, 15 Nov 2021 22:55:06 GMT" flCodeSubs="true">
						<outline text="Effect: Allow" created="Mon, 15 Nov 2021 23:05:20 GMT"/>
						<outline text="Action:" created="Mon, 15 Nov 2021 23:05:24 GMT">
							<outline text="- SSM:GetParameter" created="Mon, 15 Nov 2021 23:05:26 GMT"/>
							</outline>
						<outline text="Resource:" created="Mon, 15 Nov 2021 23:05:33 GMT">
							<outline text="- arn:aws:ssm:*:{account}:parameter/your/parameter/here" created="Mon, 15 Nov 2021 23:05:44 GMT"/>
							</outline>
						</outline>
					<outline text="Only downside of this approach would be that it violates the principal of least privilege, which may be a fair enough compromise if your goal is to reduce the number of downstream changes you'd like to make when deploying separate stacks.  This tolerance level might be different for you depending on the team your working on." created="Mon, 15 Nov 2021 22:58:12 GMT"/>
					</outline>
				</outline>
			<outline text="November 15" created="Sun, 14 Nov 2021 20:55:28 GMT" type="calendarDay" name="15">
				<outline text="Fell down the YouTube rabbit hole and found a video going through the &lt;a href=&quot;https://www.youtube.com/watch?v=TPbroUDHG0s&quot;&gt;internal workings of the NES&lt;/a&gt;.  The video itself was interesting but the take away message resonated a little, especially after the knot I found myself in yesterday." created="Sun, 14 Nov 2021 20:55:29 GMT" type="outline"/>
				</outline>
			<outline text="November 14" created="Sat, 13 Nov 2021 22:55:02 GMT" type="calendarDay" name="14">
				<outline text="Alto Catalogue Update" created="Sat, 14 Nov 2021 00:02:00 GMT" type="outline">
					<outline text="I've really tied myself up in knots here.  I'm spending some time working on &lt;a href=&quot;https://github.com/lmika/alto-catalog&quot;&gt;Alto Catalogue&lt;/a&gt;, trying to streamline the process of uploading individual tracks into a new album.  This is a workflow that is absolutely not user friendly at the moment, and the only way I've gotten tracks into the catalogue is to run a hacked-together tool to upload the tracks from the command line.  The reason why I'm addressing this now is that it's slightly embarrassing to have this open-source project without having a nice way of doing something that, by all accounts, is quite fundamental (a good hint for when you're facing this is when it comes time to write the end-user documentation: if you can't explain how to do something in a way that doesn't include the word &quot;hack&quot;, &quot;complicated&quot;, or &quot;unsupported&quot;, then something is missing)." created="Sat, 13 Nov 2021 22:55:03 GMT"/>
					<outline text="So I'm trying to close this feature gap, but it's proving to be more complicated than I expected.  The main issue relates ID3 tags and how media is arrange in the repository.  Previous versions of the catalogue actually did have a way of uploading track media to the repository, which is essentially an S3 bucket.  The way this work is that the catalogue will issue the browser a pre-signed Put URL, and the browser could upload the track media directly to S3.  But in order to get a pre-signed URL, you need to know the object key, which is a bit like a file path.  The old upload flow had the user enter the object key manually in the upload form." created="Sat, 13 Nov 2021 22:59:39 GMT"/>
					<outline text="This worked but I had some real issues with it.  The first is that I'd like the objects within the S3 bucket to be organised in a nice way, for example &quot;artist/album/tracknum-title.mp3&quot;.  I'm hoping that this S3 bucket will be my definitive music collection and I don't want just some random IDs that are completely indecipherable when I browse the objects in the S3 bucket.  That way, if I were ever to shutdown the catalogue down or loose all the metadata, I'd still be able to navigate my collection via the object keys alone." created="Sat, 13 Nov 2021 23:40:06 GMT"/>
					<outline text="The second was that this approach did not take into account the track metadata.  Track metadata is managed in a PostgreSQL database and had to be entered in manually; yes, this included the track duration.  The only reason I used the hacked together tool to upload tracks was that it was a tool I was already using to set ID3 tags on MP3 files, and it was trivial to add a HTTP client to do the upload from there.  Obviously, asking users to run a separate tool to do their track uploads is not going to fly." created="Sat, 13 Nov 2021 23:43:22 GMT"/>
					<outline text="So I'm hoping to improve this.  The ideal flow would be that the user will simply select an MP3 from their file system.  When they click upload, the following things will happen:" created="Sat, 13 Nov 2021 22:58:16 GMT" flNumberedSubs="true">
						<outline text="The ID3 tags of the MP3 will be read." created="Sat, 13 Nov 2021 23:13:34 GMT"/>
						<outline text="That metadata will be used to determine the location of the object in S3." created="Sat, 13 Nov 2021 23:47:23 GMT"/>
						<outline text="A pre-signed URL will be generated and sent to the browser to upload the file." created="Sat, 13 Nov 2021 23:47:37 GMT"/>
						<outline text="The file is uploaded to S3." created="Sat, 13 Nov 2021 23:14:10 GMT"/>
						<outline text="A new track record is created with the same metadata." created="Sat, 13 Nov 2021 23:15:38 GMT"/>
						</outline>
					<outline text="The libraries I'm using to read the &lt;a href=&quot;https://github.com/bogem/id3v2&quot;&gt;ID3 tags&lt;/a&gt; and &lt;a href=&quot;https://github.com/kgiannakakis/mp3duration&quot;&gt;track duration&lt;/a&gt; requires the track media to be available as a file on the local file system (I assume this is for random access).  Simply uploading the track media to the local file system would be the easiest approach, since it would allow me to read the metadata, upload the media to the repository on the backend, and setup the track metadata all in a single transaction.  But I have some reservations about allowing large uploads to the server, and most of the existing infrastructure already makes use of pre-signed URLs.  So the first run at this feature involved uploading the file to S3 and then downloading it on the server backend to read the metadata." created="Sat, 13 Nov 2021 23:15:56 GMT"/>
					<outline text="But you see the problem here: in order to generate a pre-signed URL to upload the object to S3, I need to know the location of the media, which I want to derive from the track metadata.  So if I don't want uploads to go straight to the file system, I need the object to already be in S3 in order to work out the best location of where to put the object in S3." created="Sat, 13 Nov 2021 23:20:39 GMT"/>
					<outline text="So I'm wondering what the best ways to fix this would be.  My current thing is this series of events:" created="Sat, 13 Nov 2021 23:26:36 GMT" flNumberedSubs="true">
						<outline text="Create a pre-signed URL to a temporary location in the S3 bucket." created="Sat, 13 Nov 2021 23:27:17 GMT"/>
						<outline text="Allow the user to Upload the media directly to that location in the S3 bucket." created="Sat, 13 Nov 2021 23:27:32 GMT"/>
						<outline text="On the server, download that media object to get the metadata and duration." created="Sat, 13 Nov 2021 23:27:41 GMT"/>
						<outline text="From that, derive the objects location and move the object within S3, something I'm guessing should be relatively easy if the objects are in the same bucket." created="Sat, 13 Nov 2021 23:28:40 GMT"/>
						<outline text="Create a new track record from the metadata." created="Sat, 13 Nov 2021 23:29:04 GMT"/>
						</outline>
					<outline text="The alternative is biting the bullet and allowing track uploads directly to the file system.  That will simplify the crazy workflow above but means that I'll need to configure the server for large uploads.  This is not entirely without precedence though: there is a feature for uploading tracks in a zip file downloaded from a URL which uses the local file system.  So there's not a whole lot stopping me from doing this altogether." created="Sat, 13 Nov 2021 23:29:16 GMT"/>
					<outline text="The third approach might be looking for a JavaScript library to read the ID3 tags.  This is not great as I'd need to get the location from the server anyway, as the metadata-derive object location is configured on a per repository basis.  It also means I'll be mixing up different ways to get metadata." created="Sat, 13 Nov 2021 23:57:36 GMT"/>
					<outline text="In any case, not a great set of options here." created="Sat, 13 Nov 2021 23:58:52 GMT"/>
					</outline>
				</outline>
			<outline text="November 13" created="Fri, 12 Nov 2021 21:31:24 GMT" type="calendarDay" name="13">
				<outline text="A few days ago I wrote a post about some limitations I was having with Old School, including images not appearing in RSS feeds.  I don't know if Dave Winer saw it, but in either case, he has fix the bug and &lt;a href=&quot;http://scripting.com/drummer/blog/2021/11/12/203908.html?title=imagesNowIncludedInRssFeeds&quot;&gt;posted an update&lt;/a&gt; on the Release Notes blog post. If you are reading Dave, thank you for addressing this, and I'll do better in raising these issues as support requests in the future so you have a chance to look at them, instead of complaining about them here (mea culpa)." created="Fri, 12 Nov 2021 22:51:08 GMT" type="outline"/>
				<outline text="&lt;p&gt;Sebastian Holstein published a &lt;a href=&quot;https://sebastian-holstein.de/post/2021-11-08-go-1.18-features/&quot;&gt;nice blog post&lt;/a&gt; (via &lt;a href=&quot;https://golangweekly.com/issues/387&quot;&gt;Golang Weekly&lt;/a&gt;) showing the new features coming up in Go 1.18.  One of the headline features of this release is generics (a.k.a. type parameters), which is something the Go community have been asking for a while.  The maintainers have been taking their time trying to make this feature work with the language, which is something that I absolutely endorse.  Sometimes you only have a single chance to get something right, and adding generics to a language is an example of this. It would be exciting to try these generics out.&lt;/p&gt;&lt;p&gt;Another feature is the presence of a workspace file, which simplifies the process of organising a workspace with a bunch of Go packages on a single machine.  This is something that &quot;go.mod&quot; supported for a while through the &lt;a href=&quot;https://golang.org/ref/mod#go-mod-file-replace&quot;&gt;use of the &lt;code&gt;replace&lt;/code&gt; directive&lt;/a&gt;, but it was always a little cumbersome, and I imagine the addition of this file is an attempt to simplify things.&lt;/p&gt;&lt;p&gt;While it is a tad annoying that there is a need for another project related file, I have to remember that changes like this are going to happen.  These are just a natural outcome of more people making larger and larger projects using Go.  There was an elegance that came from having all packages sit in a &lt;code&gt;GOPATH&lt;/code&gt; directory structure, but this made it difficult to deal with several versions of the same package.  The addition of &quot;go.mod&quot; helped with that, but made it difficult to work on several packages simultaneously.  And so the cycle continues.&lt;/p&gt;&lt;p&gt;So a little deference on my part is called for.  After all, no one has perfect knowledge of what problems they will face when they start a project.  I should always keep that in mind.&lt;/p&gt;" created="Fri, 12 Nov 2021 21:31:25 GMT" type="outline"/>
				</outline>
			<outline text="November 11" created="Wed, 10 Nov 2021 22:39:18 GMT" type="calendarDay" name="11">
				<outline text="A Tool That (Almost) Solved My Step Function Woes" created="Thu, 11 Nov 2021 02:52:09 GMT" type="outline">
					<outline text="I reached the end of my tether at work today on the task I was working on.  The nature of the task involved crafting an AWS Step Function with several steps.  Each step on the critical path contained some error handling, and several of them contained some cleanup logic, that had to be called by a bunch of other steps.  This cleanup sequence is relatively complicated, and I've raised a number of PR's to my colleagues which have come back with requests for change." created="Thu, 11 Nov 2021 01:42:13 GMT"/>
					<outline text="I'll admit that I may have been a little sloppy with this change.  But what's not helping matters is the representation of Step Functions as a finite state machine written in YAML.  I wrote about my issue with &lt;a href=&quot;https://workingset.net/2021/11/03/024751.html?title=yamlAndAccidentalProgrammingLanguageDesign&quot;&gt;YAML used as some weird general purpose programming language&lt;/a&gt;, and this applies here as well.  But a contributing factor is the level at which I'm defining this Step Function.fearing the sunk cost of the work I've done so far, I figured I'd just make the adjustments as they came.  But now my patients has run out and I figured it was time to try a different approach." created="Thu, 11 Nov 2021 01:44:44 GMT"/>
					<outline text="The way to build an AWS Step Function is to define a &lt;a href=&quot;https://en.wikipedia.org/wiki/Finite-state_machine&quot;&gt;finite state machine (FSM)&lt;/a&gt;, which is basically a set of states linked together to form a graph.  Doing this manually with a handful of states is relatively simple, but when you start to consider proper error handling and clean-up logic, such as making changes to DynamoDB records that need to be changed or reversed when something goes wrong, it can get quite complicated.  The thing is that this is something that computers are able to do for a long time.  A Turing complete program is a subset of a finite state machine, so if it's possible to represent something that is Turing complete in a regular programming language, it should be possible to do likewise for a FSM with a subset of the language." created="Thu, 11 Nov 2021 02:34:19 GMT"/>
					<outline text="So I spent some time today trying to do that.  My idea was to build a pre-processor which will take a Step Function definition encoded in the form that looks like a regular programming language, and translate it to the YAML FSM structure that AWS actually uses.  Spoiler alert: I only got about half way through, but the seeds for something that could be used down the line are there, so it wasn't a total waste of time. " created="Thu, 11 Nov 2021 01:47:18 GMT"/>
					<outline text="&lt;h3&gt;The Design&lt;/h3&gt;" created="Thu, 11 Nov 2021 01:52:26 GMT"/>
					<outline text="There's really nothing special about this.  At this very early stage, the step function is simply written as if it was a regular programming language.  The tool will read this, produce a graph representing the FSM, and generate the YAML file.  An example of how this language looks is given below:" created="Thu, 11 Nov 2021 01:53:15 GMT" flCodeSubs="true">
						<outline text="pass(name = &quot;Pass1&quot;)" created="Thu, 11 Nov 2021 01:53:59 GMT"/>
						<outline text="pass(name = &quot;Pass2&quot;)" created="Thu, 11 Nov 2021 01:54:20 GMT"/>
						</outline>
					<outline text="Here, we have a simple step function with two states, with one that will run after the other.  Running it will produce the following YAML file:" created="Thu, 11 Nov 2021 01:54:25 GMT" flCodeSubs="true">
						<outline text="Comment: This is a comment that is actually hard coded" created="Thu, 11 Nov 2021 01:55:05 GMT"/>
						<outline text="StartAt: Pass1" created="Thu, 11 Nov 2021 01:55:20 GMT"/>
						<outline text="States:" created="Thu, 11 Nov 2021 01:55:38 GMT">
							<outline text="Pass1:" created="Thu, 11 Nov 2021 01:55:42 GMT">
								<outline text="Type: Pass" created="Thu, 11 Nov 2021 01:55:45 GMT"/>
								<outline text="Next: Pass2" created="Thu, 11 Nov 2021 01:55:49 GMT"/>
								</outline>
							<outline text="Pass2:" created="Thu, 11 Nov 2021 01:55:56 GMT">
								<outline text="Type: Pass" created="Thu, 11 Nov 2021 01:55:58 GMT"/>
								<outline text="End: true" created="Thu, 11 Nov 2021 01:56:00 GMT"/>
								</outline>
							</outline>
						</outline>
					<outline text="In this scenario, we're using the Pass state, which will simply succeed, so this step function is pretty useless.  But it does give a good demonstration as to what the eventual goal of the preprocessor is, which is to automatically do the wiring between the various states so that you don't have to.  If I were to put &lt;code&gt;Pass2&lt;/code&gt; above &lt;code&gt;Pass1&lt;/code&gt;, it will update the generated YAML file to reflect that, so that &lt;code&gt;Pass2&lt;/code&gt; will have &lt;code&gt;Next: Pass1&lt;/code&gt;, and &lt;code&gt;Pass1&lt;/code&gt; will have &lt;code&gt;End: true&lt;/code&gt;." created="Thu, 11 Nov 2021 01:56:03 GMT"/>
					<outline text="The usefulness of the tool comes when we start considering failure modes.  These can be expressed as normal &quot;try-catch&quot; blocks, a lot like may languages that exist today:" created="Thu, 11 Nov 2021 01:58:27 GMT" flCodeSubs="true">
						<outline text="try {" created="Thu, 11 Nov 2021 01:59:31 GMT">
							<outline text="pass(name = &quot;DoSomething&quot;)" created="Thu, 11 Nov 2021 01:59:36 GMT"/>
							</outline>
						<outline text="} catch {" created="Thu, 11 Nov 2021 01:59:56 GMT">
							<outline text="pass(name = &quot;SomethingFailed&quot;)" created="Thu, 11 Nov 2021 02:00:01 GMT"/>
							</outline>
						<outline text="} finally {" created="Thu, 11 Nov 2021 02:00:18 GMT">
							<outline text="pass(name = &quot;DoAlways&quot;)" created="Thu, 11 Nov 2021 02:00:20 GMT"/>
							</outline>
						<outline text="}" created="Thu, 11 Nov 2021 02:00:28 GMT"/>
						</outline>
					<outline text="This will produce the following Step Function YAML file:" created="Thu, 11 Nov 2021 02:00:30 GMT" flCodeSubs="true">
						<outline text="Comment: This is a comment that is actually hard coded" created="Thu, 11 Nov 2021 02:00:46 GMT"/>
						<outline text="StartAt: DoSomething" created="Thu, 11 Nov 2021 02:00:54 GMT"/>
						<outline text="States:" created="Thu, 11 Nov 2021 02:00:59 GMT">
							<outline text="DoSomething:" created="Thu, 11 Nov 2021 02:01:01 GMT">
								<outline text="Type: Pass" created="Thu, 11 Nov 2021 02:01:06 GMT"/>
								<outline text="Catch:" created="Thu, 11 Nov 2021 02:01:17 GMT">
									<outline text="-" created="Thu, 11 Nov 2021 02:54:01 GMT">
										<outline text="ErrorEquals: [&quot;States.ALL&quot;]" created="Thu, 11 Nov 2021 02:01:20 GMT"/>
										<outline text="Next: SomethingFailed" created="Thu, 11 Nov 2021 02:01:37 GMT"/>
										</outline>
									</outline>
								<outline text="Next: DoAlways" created="Thu, 11 Nov 2021 02:01:09 GMT"/>
								</outline>
							<outline text="SomethingFailed:" created="Thu, 11 Nov 2021 02:01:12 GMT">
								<outline text="Type: Pass" created="Thu, 11 Nov 2021 02:01:55 GMT"/>
								<outline text="Next: DoAlways" created="Thu, 11 Nov 2021 02:02:00 GMT"/>
								</outline>
							<outline text="DoAlways:" created="Thu, 11 Nov 2021 02:02:09 GMT">
								<outline text="Type: Pass" created="Thu, 11 Nov 2021 02:02:13 GMT"/>
								<outline text="End: true" created="Thu, 11 Nov 2021 02:02:15 GMT"/>
								</outline>
							</outline>
						</outline>
					<outline text="Once again, this is a relatively simple graph at this stage.  But imagine this growing to several nested try-catch blocks, each one with slightly different error handling and cleanup logic.  Manually keeping the various states wired correctly would be quite difficult, and it only makes sense to offload it to a tool to do this for us." created="Thu, 11 Nov 2021 02:02:17 GMT"/>
					<outline text="&lt;h3&gt;The Implementation&lt;/h3&gt;" created="Thu, 11 Nov 2021 02:03:08 GMT"/>
					<outline text="A few notes about how the tool itself was build:" created="Thu, 11 Nov 2021 02:03:20 GMT" flBulletedSubs="true">
						<outline text="It was hacked together in Go, which is my language of choice." created="Thu, 11 Nov 2021 02:03:27 GMT"/>
						<outline text="The parser was built using &lt;a href=&quot;https://github.com/alecthomas/participle&quot;&gt;Participle&lt;/a&gt;, which is an excellent library for building parsers from annotated structs.  If you work with Go and ever considered building a DSL, I would highly recommend this library." created="Thu, 11 Nov 2021 02:03:49 GMT"/>
						<outline text="The YAML document is serialised using &lt;a href=&quot;https://pkg.go.dev/gopkg.in/yaml.v2&quot;&gt;this YAML library&lt;/a&gt;." created="Thu, 11 Nov 2021 02:05:10 GMT"/>
						</outline>
					<outline text="The tool was a complete hack job so I don't want to go too much into the design.  But the general approach is the following:" created="Thu, 11 Nov 2021 02:05:46 GMT" flBulletedSubs="true">
						<outline text="First the &quot;program&quot; is parsed from stdin and translated into an &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;AST&lt;/a&gt;." created="Thu, 11 Nov 2021 02:06:15 GMT"/>
						<outline text="This AST is then converted into an internal representation of the Step Function.  This is effectively the graph, with all the steps linked together via pointers." created="Thu, 11 Nov 2021 02:07:08 GMT"/>
						<outline text="The graph is then traversed and converted into a series of structs which, when serialised, will produce the YAML document that can be loaded into AWS." created="Thu, 11 Nov 2021 02:07:47 GMT"/>
						</outline>
					<outline text="The tool does not do everything.  For example, choices are not supported, and only a few tasks that were specific to my problem were actually built." created="Thu, 11 Nov 2021 02:08:20 GMT"/>
					<outline text="So how did it go?  Well, OK, I'll come clean.  I got as far as adding support for try-catch statements, but I never actually used it for the task I was working on.  The task was nearing it's completion and even though fixing the issues were annoying, it was less effort than regenerating the whole step function from scratch.  But it's likely that more step functions would be built in the future, most likely in the manner that we've been building them now: with error handling and clean-up states.  So this tool might actually come in useful yet. " created="Thu, 11 Nov 2021 02:17:32 GMT"/>
					</outline>
				</outline>
			<outline text="November 10" created="Tue, 09 Nov 2021 22:39:29 GMT" type="calendarDay" name="10">
				<outline text="A Slightly Meta Blog Post (No, Not That &quot;Meta&quot;)" created="Wed, 10 Nov 2021 05:57:20 GMT" type="outline">
					<outline text="EDIT - A previous version of this post had a list of issues.  Some of these issues had been fixed, so it seemed fair to remove the specifics from the post." created="Fri, 12 Nov 2021 22:54:01 GMT"/>
					<outline text="I'm running up against a few things in Old School that I wished behaved differently.  Don't get me wrong: I've come to like writing with Drummer, and I like the page layout of Old School.  But there are a number of little annoyances that are starting to bother me a little." created="Tue, 09 Nov 2021 23:13:14 GMT"/>
					<outline text="So, I find myself assessing my next move for this blog.  Part of me is wondering whether it's worth moving it to another CMS.  The question is, which one?  I've got some particular requirements for this blog in that the act of writing here needs to be as effortless as possible: the &quot;passive blogging&quot; style inspired by (and coined by I think) Dave Winer.  That's the reason why I got attracted to Drummer in the first place.  My experience with a few other CMS's never really gave me that (Micro.blog came close, but the separation of the post screen from the already published posts feels like a disconnect)." created="Tue, 09 Nov 2021 23:13:33 GMT"/>
					<outline text="So, once again, I'm thinking about whether this could be solved by building something.  I'm resisting the urge to do so as much as I can.  I've been down this path several times in the past, and it's always more effort than I first think (about half of that effort is realising that I need to style the web pages myself, something I'm not great at).  It also distracts me from actually writing posts.  But the ability to use something that will fit my ideal posting workflow is quite desirable." created="Wed, 10 Nov 2021 04:48:24 GMT"/>
					<outline text="That's the trouble I find myself in all too often.  Being particular about how something should be done to the extent of building something to that spec, and trying to balance that against an existing solution which is &quot;good enough&quot;.  The only problem is that this balance changes from time to time.  Good enough might be good enough for a while, but then I run into an issue that will upset that balance, and suddenly it's no longer good enough.  But there are dangers of going the other way as well: trying to improve the matter by setting off to build something, and then discovering is not worth the effort, and settling with good enough just so that you can actually use the thing you want." created="Tue, 09 Nov 2021 23:50:14 GMT"/>
					<outline text="We'll see what wins out in the end.  Maybe these limitations will eventually be addressed.  Maybe a hybrid system in which I use Drummer for writing but a different CMS for generating the posts would work.  In either case: the thought is there, and it's not easy to dismiss it." created="Tue, 09 Nov 2021 23:14:11 GMT"/>
					</outline>
				</outline>
			<outline text="November 9" created="Tue, 09 Nov 2021 00:09:35 GMT" type="calendarDay" name="09">
				<outline text="I finally got around to finishing off a new release of &lt;a href=&quot;https://feedjournaler.app/blog/2021/11/version-0.2-release/&quot;&gt;Feed Journaler&lt;/a&gt;.  Despite the lengthy time between releases, it's actually quite a small one, mainly addressing a number of bug fixes that I've personally experienced using the app, such as dealing with blog posts from Drummer.  I was hoping to release it a little sooner but I encountered a weird issue in which old posts were being imported multiple times.  I believe the issue had to do with how posts considered &quot;old&quot; were being removed from the Sqlite3 database tracking their import.  Earlier versions had this set to 7 days but I think this was way too short.  I raised it to 2 years, which is longer but does mean more records stored in the Sqlite3 database.  But from my testing I believe it shouldn't impact performance too much." created="Tue, 09 Nov 2021 03:37:36 GMT" type="outline"/>
				</outline>
			<outline text="November 8" created="Mon, 08 Nov 2021 04:43:14 GMT" type="calendarDay" name="08">
				<outline text="Ok, I lied.  I worked a tiny bit more on Broadtail, mainly around packaging and releasing.  I'm trying to get more proficient with GitHub Actions and &lt;a href=&quot;https://goreleaser.com&quot;&gt;GoReleaser&lt;/a&gt;, which is a nice little tool for building and packaging Go apps.  It even produces DEB and RPM packages, which would be useful for Broadtail as it really should be converted to a daemon (at the moment, it's just running in a detached screen session).  Shoutouts to Alex E. Patrakov for his blog-post on &lt;a href=&quot;https://patrakov.blogspot.com/2011/01/writing-systemd-service-files.html&quot;&gt;writing systemd definitions&lt;/a&gt;." created="Mon, 08 Nov 2021 04:43:15 GMT" type="outline"/>
				</outline>
			<outline text="November 7" created="Sat, 06 Nov 2021 21:32:54 GMT" type="calendarDay" name="07">
				<outline text="Feeds In Broadtail" created="Sat, 06 Nov 2021 21:32:55 GMT" type="outline">
					<outline text="My quest to watch YouTube without using YouTube got a little closer recently with the addition of feeds in Broadtail.  This uses the &lt;a href=&quot;https://mjtsai.com/blog/2020/01/16/youtube-rss-feeds/&quot;&gt;YouTube RSS feed endpoint&lt;/a&gt; to list videos recently added to a channel or playlist." created="Sat, 06 Nov 2021 21:32:59 GMT"/>
					<outline text="Feed listing, in all it's 90's web style glory." created="Sat, 06 Nov 2021 21:35:22 GMT" inlineImage="https://images.workingset.net/2021/11/07/broadtail-feeds-1.png"/>
					<outline text="There are a bunch of channels that I watch regularly but I'm very hesitant to subscribe to them within YouTube itself (sorry YouTubers, but I choose not to smash that bell icon).  I'm generally quite hesitant to give any signal to YouTube about my watching habits, feeding their machine learning models even more information about myself.  But I do want to know when new videos are available, so that I can get them into Plex once they're released.  There is where feeds come in handy." created="Sat, 06 Nov 2021 21:35:27 GMT"/>
					<outline text="Recent videos of a feed." created="Sat, 06 Nov 2021 21:37:41 GMT" inlineImage="https://images.workingset.net/2021/11/07/broadtail-feeds-2.png"/>
					<outline text="Also improved is the display of video metadata when selecting a feed item or entering a video ID in the quick look bar.  Previously this would immediately start a download of the video, but I prefer knowing more about the video first.  These downloads aren't free, and they usually take many hours to get.  Better to know more about them before committing to it." created="Sat, 06 Nov 2021 21:38:44 GMT"/>
					<outline text="Video details page." created="Sat, 06 Nov 2021 21:37:49 GMT" inlineImage="https://images.workingset.net/2021/11/07/broadtail-video-details.png"/>
					<outline text="Incidentally, I think this mode of watching has a slight benefit.  There are days when I spend the whole evening binging YouTube, not so much following the algorithm but looking at the various channels I'm interested in for videos that I haven't seen yet.  Waiting several hours for a video download feels a little more measured, and less likely to send me down the YouTube rabbit hole.  I'm sure there will still be evenings when I do nothing else other than watch TV, but hopefully that's more of a choice rather than an accident." created="Sat, 06 Nov 2021 21:46:47 GMT"/>
					<outline text="I think this is enough on Broadtail for the time being.  It's more or less functional for what I want to do with it.  Time to move onto something else." created="Sat, 06 Nov 2021 21:40:28 GMT"/>
					</outline>
				</outline>
			<outline text="November 5" created="Thu, 04 Nov 2021 23:35:06 GMT" type="calendarDay" name="05">
				<outline text="The more I think about it, the more I think Drummer would benefit from customisable keyboard shortcuts, both for the built in commands, but also for any custom scripts.  Maybe I should raise an RFC." created="Thu, 04 Nov 2021 23:35:07 GMT" type="outline"/>
				</outline>
			<outline text="November 4" created="Thu, 04 Nov 2021 00:13:35 GMT" type="calendarDay" name="04">
				<outline text="The more I deal with AWS Step Functions, and the complexity that comes with defining state machines with error handling and special case logic, the more I wish there was a way to define these step function workflows using a regular, high-level programming language." created="Thu, 04 Nov 2021 00:13:36 GMT" type="outline"/>
				<outline text="YAML and Accidental Programming Language Design" created="Thu, 04 Nov 2021 02:47:51 GMT" type="outline">
					<outline text="I'm not a huge fan of YAML in general, but I do see it being useful for situations when a structured configuration language is needed.  Something for which JSON would normally be used, but where human readability and maintainability is important." created="Thu, 04 Nov 2021 00:23:53 GMT"/>
					<outline text="What I don't like is seeing YAML being used as a way to define a sequence of actions.  I complained about Step Functions, but just as annoying is the various CI/CD services that use YAML as the means of defining the build sequence.  Encoding a sequence of actions — complete with branches, loops, callouts, and error handling — using a language geared towards configuration is clunky at best, and I'm always curious as to why vendors choose to use it when a language more fit for purpose would be nicer to work with. (This rant is going to be about YAML but using JSON in these situations is just as bad, if not worse.  At least YAML has comments)." created="Thu, 04 Nov 2021 00:24:16 GMT"/>
					<outline text="Obviously being a well known syntax that is approachable and already has a number of available parsers is a huge advantage.  But I don't think that's the whole story, as there are plenty of JavaScript parsers out there as well.  It might be necessary to tweak the runtime a little, which is not easy, but certainly not beyond the skills of Amazon and the like.  No, I wonder if the desirability of YAML here is the ease of symbolic manipulation, and something that I'll call &quot;functionality inflation&quot; (this makes it sound like a bad thing, but I guess another way of putting it is &quot;serving the insatiable needs of the user&quot;)." created="Thu, 04 Nov 2021 00:24:28 GMT"/>
					<outline text="I'll touch on latter first, as it's probably the most sinister one.  It all begins with the first release of the feature, which starts off being very simply: just a series of actions that are executed in order.  Here too is the moment where you need to define how these sequence of actions are to be encoded.  Since the runtime is non-standard (in AWS Step Functions, actions may take up to a year to be completed), and the set of encodable actions is relatively small, it seems like going with a language like JavaScript would be overkill.  Better off to to go with something simpler, like YAML.  You don't need to build the parser; you simply need to define how the actions look in terms of arrays and objects, since that's what a parsed YAML document would give you.  You choose a representation — say as an array, with each action being an object — and ship the feature.  Easy enough." created="Thu, 04 Nov 2021 01:55:26 GMT"/>
					<outline text="The problem is that it never remains this simple.  As time goes on, and people continue to use your system, their expectations of the system begin to grow.  It eventually comes to the point where the single list of actions is not enough.  Now you need to consider actions that should only run when a certain condition is met, or actions that should run when another action fails." created="Thu, 04 Nov 2021 00:27:47 GMT"/>
					<outline text="So you extend your YAML language. You add guards to your actions which will only run when the condition is true, or start adding catch clauses to the actions to jump to another one when an error occurs.  You begin defining bizarre expression languages on top of your expanded YAML representation that never look quite right, and special fields on actions with act effectively like goto's.  Eventually, you ship that, and for a while your users are happy, but not for long.  They want variables, or actions that run multiple times or over a set of items, or the ability to call out to other actions in another workflow so they don't have to copy-and-paste, and on and on.  One day, you wake up and you realised that you've accidentally built a Turing complete programming language.  The only problem is that it's written in YAML." created="Thu, 04 Nov 2021 00:30:38 GMT"/>
					<outline text="So what's the alternative?  I'd argue something that resembles a proper, Algol-type programming language is a superior method of representing these workflows.  There are many benefits of doing so: the logic is clear, one step follows the other as you flow down the page.  There are already standard conventions for indicating branching, loops, error handling and call-outs.  And there's a lot less line noise as you're not mixing your logic in with your data and configuration." created="Thu, 04 Nov 2021 00:39:16 GMT"/>
					<outline text="I mentioned JavaScript earlier here, but would using it, or another language, be useful here?  Perhaps.  They've got available runtimes as well, but they may not be easy to work with at the source level.  This touches on the second reason why I think YAML is used, which is ease of symbolic manipulation.  Given that YAML is just a glorified way to represent arrays and objects, one could argue that the advantages of using YAML is that it's just as easy to manipulate with machines as it is from a text editor.  You could, for example, build a graphical designers on top of your definition language which will manipulate the YAML while preserving any edits done by hand.  This is something that's difficult to do with an existing language like JavaScript or Ruby.  Difficult, but not impossible.  Plus, there's nothing stopping vendors from designing a language which is high level enough to be easily manipulatable from machines.  It just needs to be easily parsed and unparsed between the code and the AST without any information loss.  This can be baked in as a top-level requirement of the language during the design." created="Thu, 04 Nov 2021 00:33:20 GMT"/>
					<outline text="In any case, it doesn't need to be this way.  We shouldn't need to encode our logic using a configuration language.  We already have better facilities for doing this: called programming languages.  I hope that next time a vendor wishes to build something that has a feature like this, they consider designing one instead of using something not quite fit for purpose like YAML." created="Thu, 04 Nov 2021 00:39:14 GMT"/>
					</outline>
				</outline>
			<outline text="November 3" created="Tue, 02 Nov 2021 22:44:30 GMT" type="calendarDay" name="03">
				<outline text="Dave Winer has released a Drummer script verb for &lt;a href=&quot;http://scripting.com/drummer/blog/2021/11/02/143316.html?title=stringmarkdownprocess&quot;&gt;processing Markdown&lt;/a&gt; so I thought I'd give it a go.  I've written a simple script which will convert the currently selected node from Markdown to HTML, which I hope to run prior to building the blog.  With any luck, this blog post — originally written in Markdown and converted using this script — would have proper formatting in place." created="Tue, 02 Nov 2021 22:44:31 GMT" type="outline"/>
				</outline>
			<outline text="November 2" created="Tue, 02 Nov 2021 02:50:54 GMT" type="calendarDay" name="02">
				<outline text="Now that Working Set is being served with a custom template, I've made a few changes in an attempt to improve page load times.&lt;p&gt;The first change was to concatenate and minified all the JavaScript and CSS files included in the page head.  I got the number of separate JavaScript loads down from 12 to 2, and the number of separate CSS loads down from 9 to 4.  This seems to have made page loads a fair bit quicker, even with the CSS files unminified (there were some weird artefacts in one of them which was causing problems).&lt;p&gt;The second change was to moved all the asset files to S3.  I'm loading the large files directly from S3 as I'm guessing it's better at serving large files than the Linode server I'm using, but the rest are going through a Pagepark server running in Docker.  This hybrid setup is a little strange, but it does gives me the ability to load resources via a subdomain of &lt;code&gt;workingset.net&lt;/code&gt;.&lt;p&gt;There are still some room for improvements, like the two 2 second delay to actually load the page.  But any improvement made is a good thing." created="Tue, 02 Nov 2021 02:50:55 GMT" type="outline" isComment="false"/>
				</outline>
			<outline text="November 1" created="Mon, 01 Nov 2021 04:53:36 GMT" type="calendarDay" name="01">
				<outline text="Things get a bit strange when you find yourself writing test helpers that effectively do the same thing as the code you're testing.  In order to test a method which puts something into S3, you need a helper to read it in order to be sure that it was saved successfully.  Similarly, when you need to test reading from S3, something needs to be put there first so it could be read. It makes you wonder whether it's easier to just have the two methods test each other." created="Mon, 01 Nov 2021 04:53:37 GMT" type="outline"/>
				</outline>
			</outline>
		</body>
	</opml>
